# Calling Convention
# r0 is 0
# r1 is the return-address and result register
# r2 is the stack pointer
# r3 is the valstack
# r4, r5 are nonvolatiles
# r6, r7 are temps
.section init
    .zero r0
    .temps r6, r7
    jumptable:
        .space 256
    init_table:
        push r1 on stack r2
        r5 := jumptable
        r4 := r5 + 256
        goto init_table_loop

    init_table_loop:
        r5 := r5 + 1        
        m[r0][r5] := input_error
        if (r4 >s r5) goto init_table_loop using r1 ######## this is the segfault issue

#################################################################
# number function
#################################################################
.section init 
    init_num_table:
        m[r0][jumptable + '0'] := number
        m[r0][jumptable + '1'] := number
        m[r0][jumptable + '2'] := number
        m[r0][jumptable + '3'] := number
        m[r0][jumptable + '4'] := number
        m[r0][jumptable + '5'] := number
        m[r0][jumptable + '6'] := number
        m[r0][jumptable + '7'] := number
        m[r0][jumptable + '8'] := number
        m[r0][jumptable + '9'] := number
.section text
    ############################################################################
    # input
    #     call stack: val stack, return address to call main
    #      val stack: state
    #           note: r4 = input, r5 = jumplocation
    # output
    #     call stack: val stack, return address to callmain, return address to
    #                 main
    #      val stack: first digit of input, state
    #           note: r5 = entering or waiting, r3 = val stack
    ############################################################################
    number:
        output 'r'
        r3 := m[r0][r2 + 1] #get val stack
        pop r5 off stack r3 #entering or waiting state = r5
        push r1 on stack r2 #return address to
        r4 := r4 - 48       #convert to decimal
        push r4 on stack r3 #input
        if (r5 == 1) goto entering using r4
        r5 := 1
        push r5 on stack r3 #setting entering state
        goto waiting

#################################################################
# space function
#################################################################
.section init 
    m[r0][jumptable + ' '] := space
.section text
    ############################################################################
    # input
    #     call stack: val stack, return address to main
    #      val stack: value(whole number), state
    #           note: r4 = input, r5 = jumplocation
    # output
    #     call stack: val stack, return address to main
    #      val stack: value, state
    #           note: r4 = input, r5 = jumplocation
    ############################################################################
    space: 
        output "space\n"
        pop r5 off stack r3 #get state
        r5 := 0 #set to waiting
        push r5 on stack r3 #push to val stack
        goto waiting #waiting again

#################################################################
# newline function
#################################################################
.section init 
    m[r0][jumptable + '\n'] := newline
.section text #val stack = r3
    ############################################################################
    # input
    #     call stack: val stack, return address to main
    #      val stack: value(s), state
    #           note: r4 = input, r5 = jumplocation
    # output
    #     call stack: val stack, return address to main, counter
    #      val stack: value(s)
    #           note: r4 = input, r5 = value
    ############################################################################
    newline: #loop through val stack to print each item
        output "new line\n"
        r3 := m[r0][r2 + 1] #get valstack
        r5 := m[r0][r3]
        r5 := r5 + 48
        output r5
        halt
        
        goto newline_loop

    newline_loop:
        output "newline_loop"
        r5 := m[r0][r3] #value
        push r0 on stack r2 #counter
        pop stack r3 #pops state off call stack
        if (r3 == endvalstack) goto waiting using r1
        r3 := r3 + 1
        goto printd linking r1
        push r0 on stack r3 #indicates waiting
        goto newline_loop

#################################################################
# add function
#################################################################
.section init 
    m[r0][jumptable + '+'] := add
.section text
    ############################################################################
    # input
    #     call stack: val stack, return address to main
    #      val stack: val1, val2, state
    #           note: r4 = input, r5 = jumplocation
    # output
    #     call stack: val stack, return address to main
    #      val stack: result, waiting
    #           note: r4 = input, r5 = jumplocation
    ############################################################################
    add:
        output "add\n"
        r3 := m[r0][r2 + 1]
        pop stack r3 #waiting state
        pop r5 off stack r3 #value 1
        pop r4 off stack r3 #value 2
        r5 := r4 + r5
        push r5 on stack r3
        push r0 on stack r3 #indicates waiting
        goto waiting

#################################################################
# subtract function
#################################################################
.section init 
    m[r0][jumptable + '-'] := sub
.section text
    sub:
        output "sub\n"
        r3 := m[r0][r2 + 1]
        pop stack r3 #waiting state
        pop r5 off stack r3 #value 1
        pop r4 off stack r3 #value 2
        r5 := r4 - r5
        push r5 on stack r3
        push r0 on stack r3 #indicates waiting
        goto waiting

#################################################################
# multiply function
#################################################################
.section init 
    m[r0][jumptable + '*'] := mul
.section text
    mul:
        output "mul\n"
        r3 := m[r0][r2 + 1]
        pop stack r3 #waiting state
        pop r5 off stack r3 #value 1
        pop r4 off stack r3 #value 2
        r5 := r4 * r5
        push r5 on stack r3
        push r0 on stack r3 #indicates waiting
        goto waiting

#################################################################
# Division function
#################################################################
.section init 
    m[r0][jumptable + '/'] := div
.section text
    div:
        output "div\n"
        r3 := m[r0][r2 + 1]
        pop stack r3 #waiting state
        pop r5 off stack r3 #value 1
        pop r4 off stack r3 #value 2
        r5 := r4 / r5
        push r5 on stack r3
        push r0 on stack r3 #indicates waiting
        goto waiting

#################################################################
# or function
#################################################################
.section init 
    m[r0][jumptable + '|'] := or
.section text
    or:
        output "or\n"
        r3 := m[r0][r2 + 1]
        pop stack r3 #waiting state
        pop r5 off stack r3 #value 1
        pop r4 off stack r3 #value 2
        r5 := r4 | r5
        push r5 on stack r3
        push r0 on stack r3 #indicates waiting
        goto waiting

#################################################################
# and function
#################################################################
.section init 
    m[r0][jumptable + '&'] := and
.section text
    and:
        output "and\n"
        r3 := m[r0][r2 + 1]
        pop stack r3 #waiting state
        pop r5 off stack r3 #value 1
        pop r4 off stack r3 #value 2
        r5 := r4 & r5
        push r5 on stack r3
        push r0 on stack r3 #indicates waiting
        goto waiting

#################################################################
# change sign function
#################################################################
.section init 
    m[r0][jumptable + 'c'] := changesign
.section text
    changesign:
        output "changesign\n"
        r3 := m[r0][r2 + 1]
        pop stack r3 #waiting state
        pop r5 off stack r3 #value 1
        r5 := -r5
        push r5 on stack r3
        push r0 on stack r3 #indicates waiting
        goto waiting

#################################################################
# swap function
#################################################################
.section init 
    m[r0][jumptable + 's'] := swap
.section text
    swap:
        output "swap\n"
        r3 := m[r0][r2 + 1]
        pop stack r3 #waiting state
        pop r5 off stack r3 #value 1
        pop r4 off stack r3 #value 2
        push r5 on stack r3
        push r4 on stack r3
        push r0 on stack r3 #indicates waiting
        goto waiting

#################################################################
# negation function
#################################################################
.section init 
    m[r0][jumptable + '~'] := neg
.section text
    neg:
        output "neg\n"
        r3 := m[r0][r2 + 1]
        pop stack r3 #waiting state
        pop r5 off stack r3 #value 1
        r5 := ~r5
        push r5 on stack r3
        push r0 on stack r3 #indicates waiting
        goto waiting

#################################################################
# duplicate function
#################################################################
.section init 
    m[r0][jumptable + 'd'] := dup
.section text
    dup:
        output "dup\n"
        r3 := m[r0][r2 + 1]
        pop stack r3 #waiting state
        pop r5 off stack r3 #value 1
        push r5 on stack r3
        push r5 on stack r3
        push r0 on stack r3 #indicates waiting
        goto waiting

#################################################################
# popoff function
#################################################################
.section init 
    m[r0][jumptable + 'p'] := popoff
.section text
    popoff:
        output "popoff\n"
        r3 := m[r0][r2 + 1]
        pop stack r3 #waiting state
        pop stack r3 #value 
        push r0 on stack r3 #indicates waiting
        goto waiting

#################################################################
# zerostack function -- figure this out i guess
#################################################################
.section init 
    m[r0][jumptable + 'z'] := zerostack
.section text
    zerostack:
        output "zerostack -- needs functionality\n"
        r3 := m[r0][r2 + 1]
        pop stack r3 #waiting state
        pop stack r3 #value 
        push r0 on stack r3 #indicates waiting
        goto waiting

.section text
    ############################################################################
    # input
    #     call stack: val stack, return address to callmain, return address to
    #                 main
    #      val stack: second val, last digit of input
    #           note: r5 = entering or waiting, r3 = val stack
    # output
    #     call stack: val stack, return address to callmain, return address to
    #                 main
    #      val stack: new value, state
    #           note: r4 = first digit input, r1 = entering
    ############################################################################
    entering:
        output "entering\n"
        pop r4 off stack r3 #last digit input
        pop r1 off stack r3 #other digit
        r1 := r1 * 10
        r1 := r1 + r4
        push r1 on stack r3
        r5 := 1 #entering
        push r5 on stack r3
        goto waiting

    ############################################################################
    # input
    #     call stack: val stack, return address to main
    #      val stack: state
    #           note: 
    # output
    #     call stack: val stack, return address to main
    #      val stack: state
    #           note: r4 = input
    ############################################################################
    waiting:
        output "waiting\n"
        # push r1 on stack r2
        r4 := input() #12 2 +\n
        # if r4 mod 10 == r4  goto print single digit
        goto waiting_with_character
    
    
    ############################################################################
    # input
    #     call stack: val stack, return address to main
    #      val stack: state
    #           note: r4 = input
    # output
    #     call stack: val stack, return address to main
    #      val stack: state
    #           note: r4 = input, r5 = jumplocation
    ############################################################################
    waiting_with_character:
        #pop r5 off stack r3 #waiting or entering state
        output "waiting w/ character\n"
        #if (r5 == EOF) goto exit_prog
        output r4
        r5 := jumptable + r4
        r5 := m[r0][r5]
        goto r5 #linking r1
    
    input_error:
        output 'q'
        halt

    ############################################################################
    # input
    #     call stack: empty
    #      val stack: empty
    #           note: 
    # output
    #     call stack: val stack, return address to main
    #      val stack: state
    #           note: 
    ############################################################################
    main:
        output "main\n"
        r0 := 0
        r3 := endvalstack
        push r3 on stack r2 #push value stack on call stack (m[0][r2 + 1])
        push r1 on stack r2 #return address
        push r0 on stack r3 
        goto waiting linking r1

        #program goes to exit program on its own.
        pop r1 off stack r2
        goto r1

    # check1: #change sign, negate, dup, pop, newline  
    #     #ensure somehow that there is a value on the value stack
    #     push r4 on stack r2
        
        
    #     pop r4 off stack r3
    #     if (m[r0][jumptable + r4] != input_error)


    #     pop r4 off stack r2
    # check2: #add, sub, mult, div, or, and, swap
    #     #ensure there are two values on the valuestack

    exit_prog:
        output "program exiting"
        halt