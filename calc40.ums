# Calling Convention
# r0 is 0
# r1 is the return-address and result register
# r2 is the stack pointer
# r3 is the valstack
# r4, r5 are nonvolatiles
# r6, r7 are temps
.section init
    .zero r0
    .temps r6, r7
    jumptable:
        .space 256
    init_table:
        push r1 on stack r2
        r5 := jumptable
        r4 := r5 + 256
        goto init_table_loop

    init_table_loop:
        r5 := r5 + 1        
        m[r0][r5] := input_error
        if (r4 >s r5) goto init_table_loop using r1

#################################################################
# number function
# 
# input
#     call stack: val stack, return address to call main
#      val stack: state
#           note: r4 = input, r5 = jumplocation
# output
#     call stack: val stack, return address to callmain, return address to
#                 main
#      val stack: first digit of input, state
#           note: r5 = entering or waiting, r3 = val stack
#################################################################
.section init 
    init_num_table:
        m[r0][jumptable + '0'] := number
        m[r0][jumptable + '1'] := number
        m[r0][jumptable + '2'] := number
        m[r0][jumptable + '3'] := number
        m[r0][jumptable + '4'] := number
        m[r0][jumptable + '5'] := number
        m[r0][jumptable + '6'] := number
        m[r0][jumptable + '7'] := number
        m[r0][jumptable + '8'] := number
        m[r0][jumptable + '9'] := number
.section text
    number:
        pop r5 off stack r3 #entering or waiting state = r5   
        r4 := r4 - 48       #convert to decimal
        push r4 on stack r3 #input
        if (r5 == 1) goto entering using r1
        r5 := 1
        push r5 on stack r3 #setting entering state
        goto waiting

#################################################################
# space function
# 
# input
#     call stack: val stack, return address to main
#      val stack: value(whole number), state
#           note: r4 = input, r5 = jumplocation
# output
#     call stack: val stack, return address to main
#      val stack: value, state
#           note: r4 = input, r5 = jumplocation
#################################################################
.section init 
    m[r0][jumptable + ' '] := space
.section text
    space: 
        pop r5 off stack r3 #get state
        r5 := 0 #set to waiting
        push r5 on stack r3 #push to val stack
        goto waiting #waiting again

#################################################################
# newline function
# 
# input
#     call stack: val stack, return address to main
#      val stack: value(s), state
#           note: r4 = input, r5 = jumplocation
# output
#     call stack: val stack, return address to main, counter
#      val stack: value(s)
#           note: r4 = input, r5 = value
#################################################################
.section init 
    m[r0][jumptable + '\n'] := newline
.section text #val stack = r3
    newline: #loop through val stack to print each item
        pop stack r3 #pops state off value stack

        push r1 on stack r2
        push r4 on stack r2
        r4 := endvalstack - r3
        if (r4 == r0) goto newline_noinput using r1
        pop r4 off stack r2
        pop r1 off stack r2

        r1 := m[r0][r3]
        
        r4 := r3 #saves address of value stack in r3
        goto newline_loop

    newline_loop:
        if (r4 == endvalstack) goto post_print using r1
        r5 := m[r0][r4] #value
        push r4 on stack r2
        push r0 on stack r2 #counter
        goto printd linking r1
        r4 := r4 + 1 #increase address to point to next value   
        goto newline_loop

    post_print:
        pop stack r2
        r3 := m[r0][r2]
        pop stack r3
        r4 := m[r0][r3]
        push r0 on stack r3
        goto waiting

    newline_noinput:
        pop r4 off stack r2
        pop r1 off stack r2
        push r0 on stack r3
        goto waiting



#################################################################
# add function
# 
# input
#     call stack: val stack, return address to main
#      val stack: val1, val2, state
#           note: r4 = input, r5 = jumplocation
# output
#     call stack: val stack, return address to main
#      val stack: result, waiting
#           note: r4 = input, r5 = jumplocation
#################################################################
.section init 
    m[r0][jumptable + '+'] := add
.section text
    add:
        push r1 on stack r2
        goto check2 linking r1
        pop r1 off stack r2
        r3 := m[r0][r2 + 1]
        pop stack r3 #waiting state
        pop r5 off stack r3 #value 1
        pop r4 off stack r3 #value 2
        r5 := r4 + r5
        push r5 on stack r3
        push r0 on stack r3 #indicates waiting
        goto waiting

#################################################################
# subtract function
# 
# input
#     call stack: val stack, return address to main
#      val stack: val1, val2, state
#           note: r4 = input, r5 = jumplocation
# output
#     call stack: val stack, return address to main
#      val stack: result, waiting
#           note: r4 = input, r5 = jumplocation
#################################################################
.section init 
    m[r0][jumptable + '-'] := sub
.section text
    sub:
        push r1 on stack r2
        goto check2 linking r1
        pop r1 off stack r2
        r3 := m[r0][r2 + 1]
        pop stack r3 #waiting state
        pop r5 off stack r3 #value 1
        pop r4 off stack r3 #value 2
        r5 := r4 - r5
        push r5 on stack r3
        push r0 on stack r3 #indicates waiting
        goto waiting

#################################################################
# multiply function
# 
# input
#     call stack: val stack, return address to main
#      val stack: val1, val2, state
#           note: r4 = input, r5 = jumplocation
# output
#     call stack: val stack, return address to main
#      val stack: result, waiting
#           note: r4 = input, r5 = jumplocation
#################################################################
.section init 
    m[r0][jumptable + '*'] := mul
.section text
    mul:
        push r1 on stack r2
        goto check2 linking r1
        pop r1 off stack r2
        r3 := m[r0][r2 + 1]
        pop stack r3 #waiting state
        pop r5 off stack r3 #value 1
        pop r4 off stack r3 #value 2
        r5 := r4 * r5
        push r5 on stack r3
        push r0 on stack r3 #indicates waiting
        goto waiting

#################################################################
# Division function
# 
# input
#     call stack: val stack, return address to main
#      val stack: val1, val2, state
#           note: r4 = input, r5 = jumplocation
# output
#     call stack: val stack, return address to main
#      val stack: result, waiting
#           note: r4 = input, r5 = jumplocation
#################################################################
.section init 
    m[r0][jumptable + '/'] := div
.section text
    div:
        push r1 on stack r2
        goto check2 linking r1
        pop r1 off stack r2
        r3 := m[r0][r2 + 1]
        pop stack r3 #waiting state
        pop r5 off stack r3 #value 1
        pop r4 off stack r3 #value 2
        push r1 on stack r2

        if (r5 == r0) goto divzero using r1
        if (r5 <s r0) goto first_negative using r1
        if (r4 <s r0) goto second_negative using r1

        r5 := r4 / r5
        push r5 on stack r3
        push r0 on stack r3 #indicates waiting
        pop r1 off stack r2
        goto waiting

    divzero:
        output "Division by zero\n"
        push r4 on stack r3
        push r5 on stack r3
        push r0 on stack r3 #indicates waiting
        pop r1 off stack r2
        goto waiting

    first_negative:
        if (r4 <s 0) goto bothnegative using r1
        r5 := -r5
        r5 := r4 / r5
        r5 := -r5
        push r5 on stack r3
        push r0 on stack r3
        pop r1 off stack r2
        goto waiting

    second_negative:
        r4 := -r4
        r4 := r5 / r4
        r4 := -r4
        push r4 on stack r3
        push r0 on stack r3
        pop r1 off stack r2
        goto waiting

    bothnegative:
        r4 := -r4
        r5 := -r5
        r5 := r4 / r5
        push r5 on stack r3
        push r0 on stack r3
        pop r1 off stack r2
        goto waiting

#################################################################
# or function
# 
# input
#     call stack: val stack, return address to main
#      val stack: val1, val2, state
#           note: r4 = input, r5 = jumplocation
# output
#     call stack: val stack, return address to main
#      val stack: result, waiting
#           note: r4 = input, r5 = jumplocation
#################################################################
.section init 
    m[r0][jumptable + '|'] := or
.section text
    or:
        push r1 on stack r2
        goto check2 linking r1
        pop r1 off stack r2
        r3 := m[r0][r2 + 1]
        pop stack r3 #waiting state
        pop r5 off stack r3 #value 1
        pop r4 off stack r3 #value 2
        r5 := r4 | r5
        push r5 on stack r3
        push r0 on stack r3 #indicates waiting
        goto waiting

#################################################################
# and function
# 
# input
#     call stack: val stack, return address to main
#      val stack: val1, val2, state
#           note: r4 = input, r5 = jumplocation
# output
#     call stack: val stack, return address to main
#      val stack: result, waiting
#           note: r4 = input, r5 = jumplocation
#################################################################
.section init 
    m[r0][jumptable + '&'] := and
.section text
    and:
        push r1 on stack r2
        goto check2 linking r1
        pop r1 off stack r2
        r3 := m[r0][r2 + 1]
        pop stack r3 #waiting state
        pop r5 off stack r3 #value 1
        pop r4 off stack r3 #value 2
        r5 := r4 & r5
        push r5 on stack r3
        push r0 on stack r3 #indicates waiting
        goto waiting

#################################################################
# change sign function
# 
# input
#     call stack: val stack, return address to main
#      val stack: val1, state
#           note: r4 = input, r5 = jumplocation
# output
#     call stack: val stack, return address to main
#      val stack: result, waiting
#           note: r4 = input, r5 = jumplocation
#################################################################
.section init 
    m[r0][jumptable + 'c'] := changesign
.section text
    changesign:
        push r1 on stack r2
        goto check1 linking r1
        pop r1 off stack r2
        r3 := m[r0][r2 + 1]
        pop stack r3 #waiting state
        pop r5 off stack r3 #value 1
        r5 := -r5
        push r5 on stack r3
        push r0 on stack r3 #indicates waiting
        goto waiting

#################################################################
# swap function
# 
# input
#     call stack: val stack, return address to main
#      val stack: val1, val2, state
#           note: r4 = input, r5 = jumplocation
# output
#     call stack: val stack, return address to main
#      val stack: result, waiting
#           note: r4 = input, r5 = jumplocation
#################################################################
.section init 
    m[r0][jumptable + 's'] := swap
.section text
    swap:
        push r1 on stack r2
        goto check2 linking r1
        pop r1 off stack r2
        r3 := m[r0][r2 + 1]
        pop stack r3 #waiting state
        pop r5 off stack r3 #value 1
        pop r4 off stack r3 #value 2
        push r5 on stack r3
        push r4 on stack r3
        push r0 on stack r3 #indicates waiting
        goto waiting

#################################################################
# negation function
# 
# input
#     call stack: val stack, return address to main
#      val stack: val1, state
#           note: r4 = input, r5 = jumplocation
# output
#     call stack: val stack, return address to main
#      val stack: result, waiting
#           note: r4 = input, r5 = jumplocation
#################################################################
.section init 
    m[r0][jumptable + '~'] := neg
.section text
    neg:
        push r1 on stack r2
        goto check1 linking r1
        pop r1 off stack r2
        r3 := m[r0][r2 + 1]
        pop stack r3 #waiting state
        pop r5 off stack r3 #value 1
        r5 := ~r5
        push r5 on stack r3
        push r0 on stack r3 #indicates waiting
        goto waiting

#################################################################
# duplicate function
# 
# input
#     call stack: val stack, return address to main
#      val stack: val1, val2, state
#           note: r4 = input, r5 = jumplocation
# output
#     call stack: val stack, return address to main
#      val stack: result, waiting
#           note: r4 = input, r5 = jumplocation
#################################################################
.section init 
    m[r0][jumptable + 'd'] := dup
.section text
    dup:
        push r1 on stack r2
        goto check1 linking r1
        pop r1 off stack r2
        r3 := m[r0][r2 + 1]
        pop stack r3 #waiting state
        pop r5 off stack r3 #value 1
        push r5 on stack r3
        push r5 on stack r3
        push r0 on stack r3 #indicates waiting
        goto waiting

#################################################################
# popoff function
# 
# input
#     call stack: val stack, return address to main
#      val stack: val1, val2, state
#           note: r4 = input, r5 = jumplocation
# output
#     call stack: val stack, return address to main
#      val stack: result, waiting
#           note: r4 = input, r5 = jumplocation
#################################################################
.section init 
    m[r0][jumptable + 'p'] := popoff
.section text
    popoff:
        push r1 on stack r2
        goto check1 linking r1
        pop r1 off stack r2
        r3 := m[r0][r2 + 1]
        pop stack r3 #waiting state
        pop stack r3 #value 
        push r0 on stack r3 #indicates waiting
        goto waiting

#################################################################
# zerostack function 
# 
# input
#     call stack: val stack, return address to main
#      val stack: val1, val2, state
#           note: r4 = input, r5 = jumplocation
# output
#     call stack: val stack, return address to main
#      val stack: result, waiting
#           note: r4 = input, r5 = jumplocation
#################################################################
.section init 
    m[r0][jumptable + 'z'] := zerostack
.section text
    zerostack:
        push r1 on stack r2
        push r4 on stack r2
        pop stack r3 #waiting state
        r4 := endvalstack - r3
        goto zerostack_loop linking r1
        pop r4 off stack r2
        pop r1 off stack r2
        push r0 on stack r3 #indicates waiting
        goto waiting
    zerostack_loop:
        if (r4 == 0) goto r1
        pop stack r3
        r4 := r4 - 1
        goto zerostack_loop



.section text
    ############################################################################
    # entering
    # 
    # input
    #     call stack: val stack, return address to callmain, return address to
    #                 main
    #      val stack: second val, last digit of input
    #           note: r5 = entering or waiting, r3 = val stack
    # output
    #     call stack: val stack, return address to callmain, return address to
    #                 main
    #      val stack: new value, state
    #           note: r4 = first digit input, r1 = entering
    ############################################################################
    entering:
        pop r4 off stack r3 #last digit input
        pop r1 off stack r3 #other digit
        r1 := r1 * 10
        r1 := r1 + r4
        push r1 on stack r3
        r5 := 1 #entering
        push r5 on stack r3
        goto waiting

    ############################################################################
    # waiting
    # 
    # input
    #     call stack: val stack, return address to main
    #      val stack: state
    #           note: 
    # output
    #     call stack: val stack, return address to main
    #      val stack: state
    #           note: r4 = input
    ############################################################################
    waiting:
        pop r1 off stack r2     # add to main
        pop stack r2    #old valuestack
        push r3 on stack r2 #push value stack on call stack (m[0][r2 + 3])
        push r1 on stack r2
        r4 := input()
        # r0 := ~r0
        # if (r4 == r0) goto exit_prog using r5
        # r0 := 0
        goto waiting_with_character
    
    
    ############################################################################
    # waiting with character
    # input
    #     call stack: val stack, return address to main
    #      val stack: state
    #           note: r4 = input
    # output
    #     call stack: val stack, return address to main
    #      val stack: state
    #           note: r4 = input, r5 = jumplocation
    ############################################################################
    waiting_with_character:
        r5:= ~r4
        if (r5 == 0) goto exit_prog using r1
        r5 := jumptable + r4
        r5 := m[r0][r5] #jump
        goto r5 linking r1
        pop r1 off stack r2 #ret add to main
        pop stack r2 # old val stack
        push r3 on stack r2 # new val stack
        push r1 on stack r2
        goto waiting
    
    input_error:
        output "Unknown character '"
        output r4
        output "'\n"
        goto waiting

    ############################################################################
    # main
    # 
    # input
    #     call stack: empty
    #      val stack: empty
    #           note: 
    # output
    #     call stack: val stack, return address to main
    #      val stack: state
    #           note: 
    ############################################################################
    main:
        r0 := 0
        r3 := endvalstack
        push r3 on stack r2
        push r1 on stack r2 #return address
        push r0 on stack r3 
        goto waiting linking r1
        #program goes to exit program on its own.
        pop r1 off stack r2
        goto r1

    check1: #checks if there is at least one value on the val stack
        push r1 on stack r2
        push r4 on stack r2
        push r5 on stack r2
        r4 := endvalstack - r3
        if (r4 <s 2) goto arg_error1 using r5
        pop r5 off stack r2
        pop r4 off stack r2
        pop r1 off stack r2
        goto r1

    check2: #checks if there is at least 2 values on the val stack
        push r1 on stack r2
        push r4 on stack r2
        push r5 on stack r2
        r4 := endvalstack - r3
        if (r4 <s 3) goto arg_error2 using r5
        pop r5 off stack r2
        pop r4 off stack r2
        pop r1 off stack r2
        goto r1

    arg_error1: #prints error if no values on val stack and returns to waiting
        output "Stack underflow---expected at least 1 element\n"
        pop r5 off stack r2
        pop r4 off stack r2
        pop r1 off stack r2
        goto waiting

    arg_error2: #prints error if 1 value on val stack and returns to waiting
        output "Stack underflow---expected at least 2 elements\n"
        pop r5 off stack r2
        pop r4 off stack r2
        pop r1 off stack r2
        goto waiting

    exit_prog:
        r3 := m[r0][r2]
        r4 := endvalstack - r3 #valstack counter
        goto clear_valstack linking r1
        r4 := endstack - r2 #valstack counter
        goto clear_callstack linking r1
        halt

    clear_valstack:
        if (r4 == 0) goto r1
        pop stack r3

    clear_callstack:
        if (r4 == 0) goto r1
        pop stack r2


        halt