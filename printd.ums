# Calling Convention
# r0 is 0
# r1 is the return-address and result register 
# r2 is the call stack pointer 
# r3 is the value stack pointer
# r4 are nonvolatiles
# r5 is a volatile register
# r6, r7 are temps


        #case zero has leading 0
        #case 0x800000000 special case
        #case positive and negative



.section init
    .zero r0
    .temps r6, r7
    
.section text
    printd:  #assumes there is a number in the value stack
        pop r5 off stack r2     #counter
        push r1 on stack r2     #return address
        output '>'
        output '>'
        output '>'
        output ' '
        goto print_loop
        


    print_loop:
        # else get the value from the value stack rX = m[r3]

        # r4 is main value
        # r5 is counter
        # r6 and r7 used as temps

        pop r4 off stack r3         #grab value
        r5 := r5 + 1                #increasing count
        push r5 on stack r2
        r5 := 10
        r1 := r4 mod r5             #getting the least significant digit
        if ( r1 == r4 ) goto base_case using r5 #if lsd = original value, then print
        push r1 on stack r3         #pushing lsd onto value stack
        r1 := r4 / 10               #getting number without last digit
        push r1 on stack r3         #pushes number without last digit to value stack
        pop r5 off stack r2         #get counter
        goto print_loop             #restarts loop


    base_case:
        pop r5 off stack r2
        if (r5 == r0) goto exit_print using r1
                        #grab most significant digit
        r4 := r4 + 48                   #if it works it works dont ask me how
        output r4                       #print msd
        r4 := r4 - 48                    
        r5 := r5 - 1                    #decrement counter
        pop r4 off stack r3 
        push r5 on stack r2
        goto base_case 

    
    exit_print:
        output '\n'
        pop r1 off stack r2
        goto r1