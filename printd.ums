# Calling Convention
# r0 is 0
# r1 is the return-address and result register 
# r2 is the call stack pointer 
# r3 is the value stack pointer
# r4 are nonvolatiles
# r5 is a volatile register
# r6, r7 are temps


        #case zero has leading 0
        #case 0x800000000 special case
        #case positive and negative



.section init
    .zero r0
    .temps r6, r7
    
.section text
    ############################################################################
    # input
    #     call stack: val stack, return address to main, counter
    #      val stack: value(s)
    #           note: r4 = input, r5 = value
    # output
    #     call stack: val stack, return address to main, return add, value(s)
    #      val stack: value(s)
    #           note: r4 = value, r5 = counter
    ############################################################################
    printd:  #assumes there is a number in the value stack
        #output "printd"
        r4 := r5
        pop r5 off stack r2     #counter
        # r4 := r4 + 48
        # output r4
        # r4 := r4 - 48
        #pop r4 off stack r3     #value
        
        
        push r1 on stack r2     #return address to printd
        output '>'
        output '>'
        output '>'
        output ' '
        if (r4 <s r0) goto print_neg using r1
        push r4 on stack r3     #value back on value stack
        push r3 on stack r2
        push r4 on stack r2     #push value on call stack
        goto print_loop
        
    ############################################################################
    # input
    #     call stack: val stack, return address to main, return add, value(s)
    #      val stack: value(s)
    #           note: r4 = val, r5 = counter
    # output
    #     call stack: val stack, return address to main, return add, least sig
    #                 digit, mid digit, most SD
    #      val stack: value(s)
    #           note: r4 = msd, r5 = counter
    ############################################################################
    print_loop:
        #output "printloop\n"
        pop r4 off stack r2         #values
        # r4 := r4 + 48
        # output r4
        # output "test"
        # r4 := r4 - 48
        r3 := 10
        r1 := r4 mod r3             #getting the least significant digit
        r5 := r5 + 1                #increasing count
        if ( r1 == r4 ) goto base_case using r3 #if lsd = original value, then print
        push r1 on stack r2         #pushing lsd onto value stack
        r1 := r4 / 10               #getting number without last digit
        push r1 on stack r2         #pushes number without last digit to value stack
        
        goto print_loop             #restarts loop

    ############################################################################
    # input
    #     call stack: val stack, return address to main, return add, least sig
    #                 digit, mid digit, most SD
    #      val stack: value(s)
    #           note: r4 = msd, r5 = counter
    # output
    #     call stack: val stack, return address to main, return add
    #      val stack: value(s)
    #           note: r4 = lsd, r5 = counter
    ############################################################################
    base_case:
        #output "base"
        push r4 on stack r2
        # r5 := r5 + 48
        # output r5
        # r5 := r5 - 48
        if (r5 == r0) goto exit_print using r1
        r4 := r4 + 48                   
        output r4                       #print msd
        r4 := r4 - 48                    
        r5 := r5 - 1                    #decrement counter
        pop r4 off stack r2 
        pop r4 off stack r2
        goto base_case 

    ############################################################################
    # input
    #     call stack: val stack, return address to main, return add
    #      val stack: value(s)
    #           note: r4 = lsd, r5 = counter
    # output
    #     call stack: val stack, return address to main
    #      val stack: value(s)
    #           note: r4 = lsd, r5 = counter
    ############################################################################
    exit_print:
        #output "exit print"
        output '\n'
        
        pop r3 off stack r2 #value stack
        pop r1 off stack r2 #printd
        pop r4 off stack r2    #valstack address
        # pop r0 off stack r2 #callmain address
        pop stack r2 #old valstack
        push r3 on stack r2     #add new valstack as first thing on callstack
        # push r0 on stack r2
        # pop r4 off stack r2 
        # if (r1 == waiting) goto print_neg using r5
        r0 := 0
        # push r0 on stack r3 #push waiting on value stack
        goto r1
    
    print_neg:
        output '-'
        r4 := -r4
        push r4 on stack r2
        push r4 on stack r3
        goto print_loop